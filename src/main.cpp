/*
 * Sparkle: Flexible and Anti-Damage Distributed File System.
 *
 * Copyright (C) 2019 CQU STARLab. All rights reserved.
 * Author: Xxiong <xxiong@cqu.edu.cn>
 */

#include <iostream>
#include <string>
#include <spk_compat.h>
#include <spk_setproctitle.h>
#include <spk_config.h>
#include <spk_logger.h>
#include <spk_getopt.h>
#include <spk_errno.h>
#include <spk_daemon.h>
#include <spk_slab.h>
#include <spk_eventd.h>
#include <spk_core.h>

#define SPK_VERSION_MAJOR       0
#define SPK_VERSION_MINOR       0
#define SPK_VERSION_REVISION    1

/*
 * Config cell defination
 * each configuration segment has section, name and value
 */
struct spk_config_item_t {
    const char* section;
    const char* name;
    const char* value;
};

/*
 * Default configuration
 * After parsing options from console, default config_map will be 
 * generated by the follows
 */
static struct spk_config_item_t spk_config_string_default[] = {
    /* Config Section */
    {"Config", "config_path", ""},
    /* Logger Section */
    {"Logger", "config_path", "sparkle-logger.conf"},
    /* DAS Section */
    {"DAS", "backlog", "2048"},
    {"DAS", "port", "20211"},
    {"DAS", "addr", "0.0.0.0"},
    /* CSS Section */
    {"CSS", "backlog", "2048"},
    {"CSS", "port", "20212"},
    {"CSS", "addr", "0.0.0.0"},





    /* End of Config String */
    NULL
};

/* 
 * Long options defination
 */
static struct spk_optparse_long spk_long_opts_def[] = {
    /* Options for replacing configuration specificated or defaulted */
    {"server-port",             'p', SPK_OPTPARSE_REQUIRED},
    {"configuration-path",      'c', SPK_OPTPARSE_REQUIRED},
    /* Run target and return right now */
    {"check-configuration",     'C', SPK_OPTPARSE_REQUIRED},
    {"help",                    'h', SPK_OPTPARSE_NONE},
    {"usage",                   'h', SPK_OPTPARSE_NONE},
    {"version",                 'v', SPK_OPTPARSE_NONE},
    {NULL,                      NULL, SPK_OPTPARSE_NONE}
};

/*
 * Default options
 */
static struct spk_opts_default_t {
    int32_t server_port;
    char*  configuration_path;
} spk_opts_default = { 0 };

/*
 * Print current version
 */
static void spk_version() {
    std::cerr
        << "sparkle version " 
        << SPK_VERSION_MAJOR << "." 
        << SPK_VERSION_MINOR << "."
        << SPK_VERSION_REVISION << std::endl
        << "Copyright (C) 2019 CQU STARLab. All rights reserved." << std::endl;
}

/*
 * Full usage information
 * called on `-h` or `--help` options
 */
static void spk_usage() {
    std::cerr 
        << "usage: sparkle [--version][--help][--usage]" << std::endl
        << "               [--check-configuration=<path>]" << std::endl
        << "               [--configuration-path=<path>][--server-port=<port>]" << std::endl
        << "Options:" << std::endl
        << "  -p PORT, --server-port=PORT" << std::endl
        << "                            Port for listening and feeding back." << std::endl
        << "  -c PATH, --configuration-path=PATH" << std::endl
        << "                            Assign configuration files to init server." << std::endl
        << "  -C PATH, --check-configuration=PATH" << std::endl
        << "                            Check configuration files, alert on syntax error." << std::endl
        << "  -h, --help, --usage       Print this message and exit." << std::endl
        << "  -v, --version             Print the version number of make and exit." << std::endl
        << std::endl
        << "This program built for x86_64-linux-gnu, armv7-linux-gnu and x86_64-Windows-7+" << std::endl
        << "Report bugs to <bug@cqucs.ml>" << std::endl;
}

/* 
 * Brief usage information
 * called while `parse_opts()` error
 */
static void spk_usage_brief() {
    std::cerr
        << "usage: sparkle [--version][--help][--usage]" << std::endl
        << "               [--check-configuration=<path>]" << std::endl
        << "               [--configuration-path=<path>][--server-port=<port>]" << std::endl
        << std::endl
        << "`sparkle --usage` for more detail information." << std::endl;
}

/*
 * Alloc memory and generate default configuration map from default 
 * `spk_config_string_default`
 */
static std::map<std::string, std::string>* spk_config_map_init() {
    std::map<std::string, std::string> *config_map = 
        new std::map<std::string, std::string>();

    if (!config_map)
        return nullptr;

    struct spk_config_item_t* item = spk_config_string_default;
    while (item) {
        config_map->insert(std::pair<std::string, std::string>
            (std::string(item->section) + "=" + item->name, item->value));
        item++;
    }

    return config_map;
}

/*
 * Parse options and parameters from console
 */
static int spk_parse_opts(const int argc, const char **argv) {
    int ret = 0;
    char** long_argv = NULL;
    int option, longindex;
    struct spk_optparse options;

    memset(&spk_opts_default, 0, sizeof(spk_opts_default));

    long_argv = (char**)malloc(sizeof(char*) * (argc + 1));
    if (!long_argv)
        return -SPKE_NOMEM;

    for (int i = 0; i < argc; i++) {
        long_argv[i] = (char*)malloc(sizeof(char) * strlen(argv[i]) + 1);
        strcpy(long_argv[i], argv[i]);
    }
    long_argv[argc] = NULL;

    spk_optparse_init(&options, long_argv);
    while ((option = spk_optparse_long(&options, spk_long_opts_def, &longindex)) != -1) {
        switch (option) {
        case 'p':
            spk_opts_default.server_port = atoi(options.optarg);
            break;
        case 'c':
            spk_opts_default.configuration_path = options.optarg;
            break;
        case 'C':
            // TODO: Add configuration check, load configuration file and do syntax check
            //       Include sparkle.conf and logger.conf
            exit(0);
        case 'h':
            spk_usage();
            exit(0);
        case 'v':
            spk_version();
            exit(0);
        case '?':
            fprintf(stderr, "%s: %s\n", argv[0], options.errmsg);
            spk_usage_brief();
            exit(-1);
        }
    }

    char* arg = spk_optparse_arg(&options);
    if (arg) {
        fprintf(stderr, "%s: Unknown arguments!\n", argv[0]);
        do {
            printf("    %s\n", arg);
        } while (arg = spk_optparse_arg(&options));

        spk_usage_brief();
        exit(-1);
    }

    free(long_argv);
    return 0;
}

/*
 * Enable options and parameters from console
 */
static int spk_enable_opts() {
    int ret = 0;


    // TODO

    return ret;
}

/*
 * Macro for getting error position inner throwed file
 */
#define STDCERR_POSITION_IN_SRC_BEFORE_LOGGER   \
"FATAL ERROR: in file '" << __FILE__ << "', " \
<< "at line No " << __LINE__ << ", " \
<< "function '" << __FUNCTION__ << "', "


int main(int argc, const char **argv) 
{
    const char* spk_proc_name = "sparkle";
    const char* spk_main_thread_name = "sparkle-main";
    const char* spk_config_path = "sparkle.conf";

    int err = 0;
    std::map<std::string, std::string>* default_config_map = nullptr;
    struct spk_slab_chain *slab_chain = nullptr;
    const int slab_chain_size = 1024 * 64;  /* should specified by config file */
    struct spk_css_ops* css = nullptr;
    struct spk_rms_ops* rms = nullptr;
    struct spk_das_ops* das = nullptr;
    /* config unit */
    struct eventd_config_t *eventd_config = nullptr;

    spk_setproctitle(argv, spk_proc_name);
    spk_pthread_setname(pthread_self(), spk_main_thread_name);

    /* parsing options from command */
    err = spk_parse_opts(argc, argv);
    if (err) {
        /* on parse options error or get usage information */
        std::cerr << STDCERR_POSITION_IN_SRC_BEFORE_LOGGER 
            << "spk_parse_opts error" << std::endl;
        goto out;
    }

    /* init configuration mapping */
    default_config_map = spk_config_map_init();
    if (!default_config_map) {
        /* malloc failed */
        std::cerr << STDCERR_POSITION_IN_SRC_BEFORE_LOGGER 
            << "spk_config_map_init error" << std::endl;
        goto out;
    }

    /* init configuration, and load from config file */
    err = spk_config_init(spk_config_path, default_config_map);
    if (err) {
        /* error on config init, maybe its malloc failed */
        std::cerr << STDCERR_POSITION_IN_SRC_BEFORE_LOGGER
            << "spk_config_init failed" << std::endl;
        goto err_config;
    }

    /* enable options into configuration */
    err = spk_enable_opts();
    if (err) {
        std::cerr << STDCERR_POSITION_IN_SRC_BEFORE_LOGGER
            << "spk_enable_opts error." << std::endl;
        goto err_config;
    }

    /* init logger */
    err = spk_logger_init(spk_config_get_string("Logger", "config_path").c_str());
    if (err) {
        /* after logger inited, use logging `spklog_xxx` instead of `std::cerr` */
        std::cerr << STDCERR_POSITION_IN_SRC_BEFORE_LOGGER
            << "spk_logger_init failed." << std::endl;
        goto err_logger;
    }

    /* init slab allocator */
    slab_chain = new struct spk_slab_chain;
    if (!slab_chain) {
        spklog_fatal(LOGGING_POSITION, "failed to alloc slab allocator");
        goto err_slab;
    }
    spk_slab_init(slab_chain, slab_chain_size);

    /* init event driver and socket server */
    eventd_config = new struct eventd_config_t;
    if (!eventd_config) {
        spklog_fatal(LOGGING_POSITION, "failed to alloc eventd config unit");
        goto err_eventd;
    }
    /* dump eventd/css/server config */
    strcpy(eventd_config->css_conf.addr, 
        spk_config_get_string("CSS", "addr").c_str());
    eventd_config->css_conf.backlog = spk_config_get_int("CSS", "backlog");
    eventd_config->css_conf.port = spk_config_get_int("CSS", "port");
    /* dump eventd/das/server config */
    strcpy(eventd_config->das_conf.addr,
        spk_config_get_string("DAS", "addr").c_str());
    eventd_config->das_conf.backlog = spk_config_get_int("DAS", "backlog");
    eventd_config->das_conf.port = spk_config_get_int("DAS", "port");
    /* do eventd init */
    err = spk_eventd_init(eventd_config);
    if (err) {
        spklog_fatal(LOGGING_POSITION, "failed to init event driver and socket server");
        goto err_eventd;
    }
    
    /* init chunk storage subject service */
    css = new struct spk_css_ops;
    if (!css) {
        spklog_fatal(LOGGING_POSITION, "failed to alloc `spk_css_ops`");
        goto err_css;
    }
    err = spk_css_init(css);
    if (err) {
        spklog_fatal(LOGGING_POSITION, "failed to init chunk storage subject service");
        goto err_css;
    }

    /* init regional management service */
    rms = new struct spk_rms_ops;
    if (!rms) {
        spklog_fatal(LOGGING_POSITION, "failed to alloc `spk_rms_ops`");
        goto err_rms;
    }
    err = spk_rms_init(rms);
    if (err) {
        spklog_fatal(LOGGING_POSITION, "failed to init regional management service");
        goto err_rms;
    }

    /* init data access subject service */
    das = new struct spk_das_ops;
    if (!das) {
        spklog_fatal(LOGGING_POSITION, "failed to alloc `spk_das_ops`");
        goto err_das;
    }
    err = spk_das_init(das);
    if (err) {
        spklog_fatal(LOGGING_POSITION, "failed to init data access subject service");
        goto err_das;
    }

    /* init sparkle daemon service */
    err = spk_daemon_init();
    if (err) {
        spklog_fatal(LOGGING_POSITION, "failed to init sparkle daemon service");
        goto err_daemon;
    }
    err = spk_daemon_start();

err_daemon:
    spk_daemon_exit();

err_das:
    spk_das_exit();
    delete das;
    das = nullptr;

err_rms:
    spk_rms_exit();
    delete rms;
    rms = nullptr;

err_css:
    spk_css_exit();
    delete css;
    css = nullptr;

err_eventd:
    spk_eventd_exit();
    delete eventd_config;
    eventd_config = nullptr;

err_slab:
    spk_slab_destroy(slab_chain);
    delete slab_chain;
    slab_chain = nullptr;

err_logger:
    spk_logger_free();

err_config:
    spk_config_exit();
    delete default_config_map;
    default_config_map = nullptr;

out:
    return err;
}